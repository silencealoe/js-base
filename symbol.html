<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>symbol</title>
</head>

<body>
  <script>
    //  Symbol 防止属性名冲突，表示独一无二的值，第七种数据类型（null,undefined,Number,string,boolean,symbol,Object）
    let s1 = Symbol('s1');
    let s2 = Symbol('s2');
    console.log(s1)
    console.log(s2)
    // Symbol 值不能与其他类型的值进行运算，会报错
    //  let sym=Symbol(1);
    //  let n=Number(sym);  //不能转换为数值，可以转换为字符串和布尔
    //  console.log(n) 

    // ES2019提供 Symbol.prototype.description直接返回symbol的描述
    const sym = Symbol('foo');

    console.log(sym.description) //foo
    // 使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。
    // 魔术字符串：在代码中多次出现发热字符串
    //可用于消除魔术字符串，风格良好的代码应该尽量消除魔术字符串改由含义清晰的变量代替


    // 有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。

    // 重新使用同一个 Symbol 值，Symbol.for方法
    // let s1 = Symbol.for('foo');
    // let s2 = Symbol.for('foo');
    // s1 === s2 // true
    // Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。

    // Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。
    // let s1 = Symbol.for("foo");
    // Symbol.keyFor(s1) // "foo"

    // let s2 = Symbol("foo");
    // Symbol.keyFor(s2) // undefined


    //看了这么久，感觉没啥用
    

  </script>
</body>

</html>